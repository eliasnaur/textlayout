// Package binparsergen implements a binary parser and writer generator.
package binparsergen

import (
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

func generateParser() error {
	path := "test-package"
	scope, err := importSource(path)
	if err != nil {
		return err
	}

	code := generateCodeForScope(scope)

	outfile := filepath.Join(path, "parser.go")
	content := fmt.Sprintf(`
	package %s

	// Code generated by bin-parser-gen. DO NOT EDIT

	%s
	`, "testpackage", code)

	err = os.WriteFile(outfile, []byte(content), os.ModePerm)
	if err != nil {
		return err
	}

	err = exec.Command("goimports", "-w", outfile).Run()

	return err
}

// load the source go file with go/packages
func importSource(path string) (*types.Scope, error) {
	fset := token.NewFileSet()

	// Parse the input string, []byte, or io.Reader,
	// recording position information in fset.
	// ParseFile returns an *ast.File, a syntax tree.

	tmp, err := parser.ParseDir(fset, path, nil, 0)
	if err != nil {
		return nil, fmt.Errorf("parsing: %s", err)
	}
	if len(tmp) != 1 {
		return nil, fmt.Errorf("multiple packages not supported")
	}
	for _, p := range tmp {
		var files []*ast.File
		for _, file := range p.Files {
			files = append(files, file)
		}

		// A Config controls various options of the type checker.
		// The defaults work fine except for one setting:
		// we must specify how to deal with imports.
		conf := types.Config{Importer: importer.Default()}

		// Type-check the package containing only file f.
		// Check returns a *types.Package.
		pkg, err := conf.Check(path, fset, files, nil)
		if err != nil {
			return nil, fmt.Errorf("type checking: %s", err)
		}

		return pkg.Scope(), nil
	}

	panic("unreachable")
}

func generateCodeForScope(scope *types.Scope) string {
	code := ""

	for _, name := range scope.Names() {
		obj := scope.Lookup(name)
		switch obj := obj.Type().Underlying().(type) {
		case *types.Struct:
			code += generateCodeForStruct(obj, name) + "\n"
		}
		// fmt.Println(obj, obj.Type())
	}

	return code
}

// how the type is written as binary
type fixedSizeField struct {
	field *types.Var
	size  int
}

const (
	bytes1 = 1
	bytes2 = 2 // int16, uint16
	bytes3 = 3 // float24
	bytes4 = 4 // uint32
	bytes8 = 8 // uint32
)

func getBinaryLayout(t *types.Basic) (int, bool) {
	switch t.Kind() {
	case types.Bool, types.Int8, types.Uint8:
		return bytes1, true
	case types.Int16, types.Uint16:
		return bytes2, true
	case types.Int32, types.Uint32, types.Float32:
		return bytes4, true
	case types.Int64, types.Uint64, types.Float64:
		return bytes8, true
	default:
		return 0, false
	}
}

type fixedSizeFields []fixedSizeField

func fixedSizeFromStruct(st *types.Struct) fixedSizeFields {
	var fixedSize fixedSizeFields
	for i := 0; i < st.NumFields(); i++ {
		field := st.Field(i)
		switch fieldType := field.Type().Underlying().(type) {
		case *types.Basic:
			size, ok := getBinaryLayout(fieldType)
			if ok {
				fixedSize = append(fixedSize, fixedSizeField{field: field, size: size})
			} else {
				// require special care
				break
			}
		}
	}
	return fixedSize
}

// returns the total size needed by the fields
func (fs fixedSizeFields) size() int {
	totalSize := 0
	for _, field := range fs {
		totalSize += int(field.size)
	}
	return totalSize
}

func generateCodeForStruct(st *types.Struct, name string) string {
	// compute the total size to optimize bounds checking
	fixedSize := fixedSizeFromStruct(st)

	parserCode := fixedSize.generateParser("data", fmt.Sprintf("%s{}", name))

	code := fmt.Sprintf(`func parse%s(data []byte) (%s, error) {
		var out %s
		%s
		return out, nil
	}
	`, strings.Title(name), name, name, parserCode)

	writerCode := fixedSize.generateWriter("data", "item")
	code += fmt.Sprintf(`
	func (item %s) write(data []byte) []byte {
		%s
		return data
	}
	`, name, writerCode)

	return code
}
