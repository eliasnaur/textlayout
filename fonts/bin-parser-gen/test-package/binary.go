package testpackage

import (
	"encoding/binary"
	"fmt"
)

// Code generated by bin-parser-gen. DO NOT EDIT

func parseArrayLike(data []byte) (arrayLike, error) {
	var out arrayLike
	n := 0
	tmp0 := data[n:]
	if L := len(tmp0); L < 2 {
		return arrayLike{}, fmt.Errorf("EOF: expected length: 2, got %d", L)
	}
	arrayLength0 := int(binary.BigEndian.Uint16(tmp0[0:2]))
	if L := len(tmp0); L < 2+arrayLength0*26 {
		return arrayLike{}, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength0*26, L)
	}
	out.array = make([]lookup, arrayLength0)
	for i := range out.array {
		chunk := tmp0[2+i*26:]
		out.array[i].mustParse(chunk[0:])

	}
	n += 2 + arrayLength0*26

	tmp1 := data[n:]
	if L := len(tmp1); L < 2 {
		return arrayLike{}, fmt.Errorf("EOF: expected length: 2, got %d", L)
	}
	arrayLength1 := int(binary.BigEndian.Uint16(tmp1[0:2]))
	if L := len(tmp1); L < 2+arrayLength1*52 {
		return arrayLike{}, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength1*52, L)
	}
	out.array2 = make([]composed, arrayLength1)
	for i := range out.array2 {
		chunk := tmp1[2+i*52:]
		out.array2[i].mustParse(chunk[0:])

	}
	n += 2 + arrayLength1*52

	return out, nil
}

func (item arrayLike) appendTo(data []byte) []byte {
	L0 := len(data)
	data = append(data, make([]byte, 2+len(item.array)*26)...)
	dst0 := data[L0:]
	binary.BigEndian.PutUint16(dst0, uint16(len(item.array)))
	for i, v := range item.array {
		chunk := dst0[2+i*26:]
		v.writeTo(chunk)
	}
	L1 := len(data)
	data = append(data, make([]byte, 2+len(item.array2)*52)...)
	dst1 := data[L1:]
	binary.BigEndian.PutUint16(dst1, uint16(len(item.array2)))
	for i, v := range item.array2 {
		chunk := dst1[2+i*52:]
		v.writeTo(chunk)
	}

	return data
}

func parseComplexeSubtable(data []byte) (complexeSubtable, error) {
	var out complexeSubtable
	n := 0
	tmp0 := data[n:]
	if L := len(tmp0); L < 6 {
		return complexeSubtable{}, fmt.Errorf("EOF: expected length: 6, got %d", L)
	}
	_ = tmp0[5] // early bound checking
	out.version = uint16(binary.BigEndian.Uint16(tmp0[0:2]))
	out.x = int16(binary.BigEndian.Uint16(tmp0[2:4]))
	out.y = int16(binary.BigEndian.Uint16(tmp0[4:6]))
	n += 6

	tmp1 := data[n:]
	if L := len(tmp1); L < 2 {
		return complexeSubtable{}, fmt.Errorf("EOF: expected length: 2, got %d", L)
	}
	arrayLength1 := int(binary.BigEndian.Uint16(tmp1[0:2]))
	if L := len(tmp1); L < 2+arrayLength1*26 {
		return complexeSubtable{}, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength1*26, L)
	}
	out.lookups = make([]lookup, arrayLength1)
	for i := range out.lookups {
		chunk := tmp1[2+i*26:]
		out.lookups[i].mustParse(chunk[0:])

	}
	n += 2 + arrayLength1*26

	tmp2 := data[n:]
	if L := len(tmp2); L < 28 {
		return complexeSubtable{}, fmt.Errorf("EOF: expected length: 28, got %d", L)
	}
	_ = tmp2[27] // early bound checking
	out.u.fromUint(binary.BigEndian.Uint16(tmp2[0:2]))
	out.v.fromUint(binary.BigEndian.Uint16(tmp2[2:4]))
	out.a = int64(binary.BigEndian.Uint64(tmp2[4:12]))
	out.b = int64(binary.BigEndian.Uint64(tmp2[12:20]))
	out.c = int64(binary.BigEndian.Uint64(tmp2[20:28]))
	n += 28

	tmp3 := data[n:]
	if L := len(tmp3); L < 4 {
		return complexeSubtable{}, fmt.Errorf("EOF: expected length: 4, got %d", L)
	}
	arrayLength3 := int(binary.BigEndian.Uint32(tmp3[0:4]))
	if L := len(tmp3); L < 4+arrayLength3*4 {
		return complexeSubtable{}, fmt.Errorf("EOF: expected length: %d, got %d", 4+arrayLength3*4, L)
	}
	out.array2 = make([]uint32, arrayLength3)
	for i := range out.array2 {
		chunk := tmp3[4+i*4:]
		out.array2[i] = uint32(binary.BigEndian.Uint32(chunk[0:4]))

	}
	n += 4 + arrayLength3*4

	tmp4 := data[n:]
	if L := len(tmp4); L < 8 {
		return complexeSubtable{}, fmt.Errorf("EOF: expected length: 8, got %d", L)
	}
	arrayLength4 := int(binary.BigEndian.Uint64(tmp4[0:8]))
	if L := len(tmp4); L < 8+arrayLength4*2 {
		return complexeSubtable{}, fmt.Errorf("EOF: expected length: %d, got %d", 8+arrayLength4*2, L)
	}
	out.array3 = make([]float214, arrayLength4)
	for i := range out.array3 {
		chunk := tmp4[8+i*2:]
		out.array3[i].fromUint(binary.BigEndian.Uint16(chunk[0:2]))

	}
	n += 8 + arrayLength4*2

	return out, nil
}

func (item complexeSubtable) appendTo(data []byte) []byte {
	L0 := len(data)
	data = append(data, make([]byte, 6)...)
	dst0 := data[L0:]
	_ = dst0[5] // early bound checking
	binary.BigEndian.PutUint16(dst0, uint16(item.version))
	binary.BigEndian.PutUint16(dst0[2:], uint16(item.x))
	binary.BigEndian.PutUint16(dst0[4:], uint16(item.y))

	L1 := len(data)
	data = append(data, make([]byte, 2+len(item.lookups)*26)...)
	dst1 := data[L1:]
	binary.BigEndian.PutUint16(dst1, uint16(len(item.lookups)))
	for i, v := range item.lookups {
		chunk := dst1[2+i*26:]
		v.writeTo(chunk)
	}
	L2 := len(data)
	data = append(data, make([]byte, 28)...)
	dst2 := data[L2:]
	_ = dst2[27] // early bound checking
	binary.BigEndian.PutUint16(dst2, uint16(item.u.toUint()))
	binary.BigEndian.PutUint16(dst2[2:], uint16(item.v.toUint()))
	binary.BigEndian.PutUint64(dst2[4:], uint64(item.a))
	binary.BigEndian.PutUint64(dst2[12:], uint64(item.b))
	binary.BigEndian.PutUint64(dst2[20:], uint64(item.c))

	L3 := len(data)
	data = append(data, make([]byte, 4+len(item.array2)*4)...)
	dst3 := data[L3:]
	binary.BigEndian.PutUint32(dst3, uint32(len(item.array2)))
	for i, v := range item.array2 {
		chunk := dst3[4+i*4:]
		binary.BigEndian.PutUint32(chunk, uint32(v))
	}
	L4 := len(data)
	data = append(data, make([]byte, 8+len(item.array3)*2)...)
	dst4 := data[L4:]
	binary.BigEndian.PutUint64(dst4, uint64(len(item.array3)))
	for i, v := range item.array3 {
		chunk := dst4[8+i*2:]
		binary.BigEndian.PutUint16(chunk, uint16(v.toUint()))
	}

	return data
}

func (out *composed) mustParse(data []byte) {
	_ = data[51] // early bound checking
	out.a.mustParse(data[0:])
	out.b.mustParse(data[26:])
}

func parseComposed(data []byte) (composed, error) {
	var out composed
	if L := len(data); L < 52 {
		return composed{}, fmt.Errorf("EOF: expected length: 52, got %d", L)
	}
	out.mustParse(data)
	return out, nil
}
func (item composed) writeTo(data []byte) {
	_ = data[51] // early bound checking
	item.a.writeTo(data)
	item.b.writeTo(data[26:])
}

func (item composed) appendTo(data []byte) []byte {
	L := len(data)
	data = append(data, make([]byte, 52)...)
	dst := data[L:]
	item.writeTo(dst)
	return data
}

func (out *lookup) mustParse(data []byte) {
	_ = data[25] // early bound checking
	out.a = int32(binary.BigEndian.Uint32(data[0:4]))
	out.b = int32(binary.BigEndian.Uint32(data[4:8]))
	out.c = int32(binary.BigEndian.Uint32(data[8:12]))
	out.d = uint32(binary.BigEndian.Uint32(data[12:16]))
	out.e = int64(binary.BigEndian.Uint64(data[16:24]))
	out.g = byte(data[24])
	out.h = byte(data[25])
}

func parseLookup(data []byte) (lookup, error) {
	var out lookup
	if L := len(data); L < 26 {
		return lookup{}, fmt.Errorf("EOF: expected length: 26, got %d", L)
	}
	out.mustParse(data)
	return out, nil
}
func (item lookup) writeTo(data []byte) {
	_ = data[25] // early bound checking
	binary.BigEndian.PutUint32(data, uint32(item.a))
	binary.BigEndian.PutUint32(data[4:], uint32(item.b))
	binary.BigEndian.PutUint32(data[8:], uint32(item.c))
	binary.BigEndian.PutUint32(data[12:], uint32(item.d))
	binary.BigEndian.PutUint64(data[16:], uint64(item.e))
	data[24] = byte(item.g)
	data[25] = byte(item.h)
}

func (item lookup) appendTo(data []byte) []byte {
	L := len(data)
	data = append(data, make([]byte, 26)...)
	dst := data[L:]
	item.writeTo(dst)
	return data
}

func parseSimpleSubtable(data []byte) (simpleSubtable, error) {
	var out simpleSubtable
	n := 0
	tmp0 := data[n:]
	if L := len(tmp0); L < 6 {
		return simpleSubtable{}, fmt.Errorf("EOF: expected length: 6, got %d", L)
	}
	_ = tmp0[5] // early bound checking
	out.version = uint16(binary.BigEndian.Uint16(tmp0[0:2]))
	out.x = int16(binary.BigEndian.Uint16(tmp0[2:4]))
	out.y = int16(binary.BigEndian.Uint16(tmp0[4:6]))
	n += 6

	tmp1 := data[n:]
	if L := len(tmp1); L < 2 {
		return simpleSubtable{}, fmt.Errorf("EOF: expected length: 2, got %d", L)
	}
	arrayLength1 := int(binary.BigEndian.Uint16(tmp1[0:2]))
	if L := len(tmp1); L < 2+arrayLength1*26 {
		return simpleSubtable{}, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength1*26, L)
	}
	out.lookups = make([]lookup, arrayLength1)
	for i := range out.lookups {
		chunk := tmp1[2+i*26:]
		out.lookups[i].mustParse(chunk[0:])

	}
	n += 2 + arrayLength1*26

	tmp2 := data[n:]
	if L := len(tmp2); L < 2 {
		return simpleSubtable{}, fmt.Errorf("EOF: expected length: 2, got %d", L)
	}
	arrayLength2 := int(binary.BigEndian.Uint16(tmp2[0:2]))
	if L := len(tmp2); L < 2+arrayLength2*4 {
		return simpleSubtable{}, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength2*4, L)
	}
	out.array2 = make([]uint32, arrayLength2)
	for i := range out.array2 {
		chunk := tmp2[2+i*4:]
		out.array2[i] = uint32(binary.BigEndian.Uint32(chunk[0:4]))

	}
	n += 2 + arrayLength2*4

	return out, nil
}

func (item simpleSubtable) appendTo(data []byte) []byte {
	L0 := len(data)
	data = append(data, make([]byte, 6)...)
	dst0 := data[L0:]
	_ = dst0[5] // early bound checking
	binary.BigEndian.PutUint16(dst0, uint16(item.version))
	binary.BigEndian.PutUint16(dst0[2:], uint16(item.x))
	binary.BigEndian.PutUint16(dst0[4:], uint16(item.y))

	L1 := len(data)
	data = append(data, make([]byte, 2+len(item.lookups)*26)...)
	dst1 := data[L1:]
	binary.BigEndian.PutUint16(dst1, uint16(len(item.lookups)))
	for i, v := range item.lookups {
		chunk := dst1[2+i*26:]
		v.writeTo(chunk)
	}
	L2 := len(data)
	data = append(data, make([]byte, 2+len(item.array2)*4)...)
	dst2 := data[L2:]
	binary.BigEndian.PutUint16(dst2, uint16(len(item.array2)))
	for i, v := range item.array2 {
		chunk := dst2[2+i*4:]
		binary.BigEndian.PutUint32(chunk, uint32(v))
	}

	return data
}
