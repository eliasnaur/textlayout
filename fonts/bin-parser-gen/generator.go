// Package binparsergen implements a binary parser and writer generator.
package binparsergen

import (
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"os/exec"
	"path/filepath"
)

func Generate(path string) error {
	name, scope, err := importSource(path)
	if err != nil {
		return err
	}

	code := generateCodeForScope(scope)

	outfile := filepath.Join(path, "binary.go")
	content := fmt.Sprintf(`
	package %s

	// Code generated by bin-parser-gen. DO NOT EDIT

	%s
	`, name, code)

	err = os.WriteFile(outfile, []byte(content), os.ModePerm)
	if err != nil {
		return err
	}

	err = exec.Command("goimports", "-w", outfile).Run()

	return err
}

// load the source go file with go/packages
func importSource(path string) (string, *types.Scope, error) {
	fset := token.NewFileSet()

	// Parse the input string, []byte, or io.Reader,
	// recording position information in fset.
	// ParseFile returns an *ast.File, a syntax tree.

	tmp, err := parser.ParseDir(fset, path, nil, 0)
	if err != nil {
		return "", nil, fmt.Errorf("parsing: %s", err)
	}
	if len(tmp) != 1 {
		return "", nil, fmt.Errorf("multiple packages not supported")
	}
	for name, p := range tmp {
		var files []*ast.File
		for _, file := range p.Files {
			files = append(files, file)
		}

		// A Config controls various options of the type checker.
		// The defaults work fine except for one setting:
		// we must specify how to deal with imports.
		conf := types.Config{Importer: importer.Default()}

		// Type-check the package containing only file f.
		// Check returns a *types.Package.
		pkg, err := conf.Check(path, fset, files, nil)
		if err != nil {
			return "", nil, fmt.Errorf("type checking: %s", err)
		}

		return name, pkg.Scope(), nil
	}

	panic("unreachable")
}

func generateCodeForScope(scope *types.Scope) string {
	code := ""

	for _, name := range scope.Names() {
		obj := scope.Lookup(name)
		switch obj := obj.Type().Underlying().(type) {
		case *types.Struct:
			code += generateCodeForStruct(obj, name) + "\n"
		}
	}

	return code
}

func generateCodeForStruct(st *types.Struct, typeName string) string {
	chunks := analyseStruct(st)

	// important special case : all fields have fixed size
	if len(chunks) == 1 {
		if fs, ok := chunks[0].(fixedSizeFields); ok {
			// add a mustParse version and use it in parse
			parserCode := fs.generateMustParser("data")
			finalCode := fmt.Sprintf(`func (out *%s) mustParse(data []byte) {
			%s}
			
			`, typeName, parserCode)
			finalCode += fs.generateParserUnique(typeName)

			body := fs.generateWriter("data", "item")
			finalCode += fmt.Sprintf(`func (item %s) writeTo(data []byte) {
				%s}
				
			`, typeName, body)
			finalCode += fs.generateAppenderUnique(typeName)

			return finalCode
		}
	}

	// general case
	finalCode := generateParserForStruct(chunks, typeName)
	finalCode += generateAppenderForStruct(chunks, typeName)
	return finalCode
}

// func generateCodeForStruct(st *types.Struct, name string) string {
// 	// compute the total size to optimize bounds checking
// 	fixedSize, isFixedSize := fixedSizeFromStruct(st)
// 	arrays := arraysFromStruct(st)

// 	var finalCode string

// 	if isFixedSize {
// 		// add a mustParse version and use it in parse
// 		parserCode := fixedSize.generateMustParser("data")
// 		finalCode += fmt.Sprintf(`func (out *%s) mustParse(data []byte) {
// 			%s}

// 			`, name, parserCode)
// 	}

// 	parserCode := fixedSize.generateParser("data", fmt.Sprintf("%s{}", name), isFixedSize) + "\n"

// 	if len(arrays) != 0 {
// 		parserCode += fmt.Sprintf("n := %d\n", fixedSize.size())
// 		for _, ar := range arrays {
// 			parserCode += ar.generateParser("data", fmt.Sprintf("%s{}", name), "n") + "\n"
// 		}

// 	}

// 	finalCode += fmt.Sprintf(`func parse%s(data []byte) (%s, error) {
// 		var out %s
// 		%s
// 		return out, nil
// 	}

// 	`, strings.Title(name), name, name, parserCode)

// 	if isFixedSize {
// 		// add a writeTo version and use it in appendTo
// 		writeCode := fixedSize.generateWriter("data", "item")
// 		finalCode += fmt.Sprintf(`func (item %s) writeTo(data []byte)  {
// 			%s}

// 			`, name, writeCode)
// 	}

// 	writerCode := fixedSize.generateAppender("data", "item", isFixedSize)
// 	finalCode += fmt.Sprintf(`
// 	func (item %s) appendTo(data []byte) []byte {
// 		%s
// 		return data
// 	}

// 	`, name, writerCode)

// 	return finalCode
// }
